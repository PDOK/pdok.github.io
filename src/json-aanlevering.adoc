= PDOK JSON
Raymond Kroon <raymond.kroon@kadaster.nl>
v0.8 2015-05-10

De PDOK JSON aanleverstandaard. Om aanleveringen te stroomlijnen.

Aanlevering is gebaseerd op het volgende:

* Basis van alles is een *feature*
* Een *collection* is een verzameling van features die eenzelfde soort object (bijv. panden) beschrijven. Het is handig om dezelfde veldnamen te gebruiken, al zitten hier vooralsnog geen beperkingen op.
* Features hebben *1 geometry* en verder platte attributen
* Van features worden history bij gehouden (in het geval van wijzigingen)

IMPORTANT: collection namen en attribuut namen zijn *niet* hoofdlettergevoelig. Bij het verwerken worden ze omgezet naar kleine letters.

== Aanlevering
De aanlevering geschied in 1 bestand:

[source, json, subs="macros"]
----
{
    "_meta": {
             // hier zijn we nog niet helemaal overuit, maar een beetje meta data zou handig kunnen zijn
    },
    "dataset": "dataset-identifier",
    "features" : pass:quotes[[ _feature objects_ ]]
}
----

IMPORTANT: De volgorde is hier belangrijk! Features moet het laatste attribuut zijn.

== Features
Features hebben een aantal verplichte velden welke herkenbaar zijn aan de voorloop underscore (_)

.Verplichte velden
[horizontal]
_action:: new, change, close, delete
_id:: uniek in _collection, string
_collection:: string
_validity:: datetimestring, geldigheid vanaf tijdstip: __YYYY-MM-DD**T**HH:mm:ss.sss__ (NL) of UTC __YYYY-MM-DD**T**HH:mm:ss.sss**Z** __
_geometry:: geojson object, uitgebreid met PDOK specifieke implementaties.

Daarnaast zijn er vrije (attributen) velden. Dit mogen alleen simple types (_string, numeriek, boolean_) zijn of voorgedefinieerde functies. Het type wordt bepaald op basis van de eerste keer dat een attribuut wordt aangeboden.

=== Functies
Een functie is eigenlijk een voorgedefinieerd type. Je gebruikt het als volgt:
----
["~#functienaam", [param1, param2, ...]]
----

Soms kan het wenselijk zijn dat er een lege (null) waarde opgegeven wordt voor functies. Dan kan er null voor de parameters vector opgegeven worden:
----
["~#functienaam", null]
----

Dit zorgt ervoor dat bij eerste definitie het juiste type geregistreerd wordt. Als dit niet zo is zal het type *string* zijn.

.Beschikbare functies
[horizontal]
moment:: datetimestring (__YYYY-MM-DD**T**HH:mm:ss.sss__ of met *Z* voor UTC) -> datetime obj
date:: datestring (__YYYY-MM-DD__ of met *Z* voor UTC) -> date obj
link:: collection, id -> featurelink

=== _geometry
De bedoeling is om alle types op http://geojson.org/geojson-spec.html#geometry-objects. *Dit doen we nu nog niet.*

Daarnaast zijn er extra formaten: De enige nu is toegevoegde functionaliteit voor gml. Deze accepteerd een gml geometry string.
[source, json]
----
"_geom": { "type": "gml",
           "gml": "<gml:Polygon|Point|Linestring ... > ... </gml:Polygon|Point|Linestring| ...>"
         }
----

=== _action: "new"

[source, json]
----
{
    "_action": "new",
    "_id": "abc",
    "_collection": "voorbeeld_verzameling",
    "_validity": "2010-01-01T00:00:00.000",
    "_geometry": { "type": "gml",
               "gml": "<gml:Point srsName=\"urn:ogc:def:crs:EPSG::28992\"><gml:pos>000150.000 000380.000</gml:pos></gml:Point>"
               },
    "een_datum_veld": ["~#moment", ["2012-04-23T18:25:43.511"]],
    "vrij_veld_1": "ik ben een punt",
    "vrij_veld_2":  "ik ben een lijn",
      .
      .
      .

}
----

=== _action: "change"
Aanvullend verplicht veld bij een _change_ is *_current_validity* Deze timestring moet gelijk zijn aan de huidige ___validity__.

NOTE: Een change aanbieden sluit de huidige periode en start een nieuwe.

*Alleen meegeleverde velden worden gewijzigd*

[source, json]
----
{
    "_action": "update",
    "_id": "abc",
    "_collection": "voorbeeld_verzameling",
    "_validity": "2011-01-01T00:00:00.000",
    "_current_validity": "2010-01-01T00:00:00.000",
    "vrij_veld_1": "Ik ben een Point",
    "vrij_veld_2": null , # <1>
     .
     .
     .

}
----

<1> Als je een veld wilt verwijderen kun je hem op __null__ zetten.

=== _action: "close"
_validity zorgt er voor dat we kunnen prikken in het verleden. Daarom is er *close* om de feature af te sluiten. Bij een close mag je ook nog (een laatste keer) changes uitvoeren.

[source, json]
----
{
    "_action": "close",
    "_id": "abc",
    "_collection": "voorbeeld_verzameling",
    "_validity": "2012-01-01T00:00:00.000", # <1>
    "_current_validity": "2011-01-01T00:00:00.000",
    "sluit_reden": "Verwijderd" # <2>
}
----

<1> Dit is de "sluitingsdatum"
<2> Het mogen nieuwe velden zijn, maar ook huidige. Dezelfde regels gelden als bij een *change*

IMPORTANT: Na een close kan een object niet meer gemuteerd worden.

=== _action: "delete"
Als er een fout gemaakt is in het verleden kan hiermee de feature gereset worden, zodat alles weer opnieuw aangeboden kan worden.

[source, json]
----
{
    "_action": "delete",
    "_id": "abc",
    "_collection": "voorbeeld_verzameling",
    "_current_validity": "2012-01-01T00:00:00.000"
}
----

== Gelinkte collecties
Om relaties vast te leggen tussen features in verschillende collecties, kunnen ___parent_collection__ en ___parent_id__ vastgelegd worden.

[source, json]
----
{
    "_action": "new",
    "_id": "child-id",
    "_collection": "child_verzameling",
    "_validity": "2012-01-01T00:00:00.000"
    "_parent_collection": "voorbeeld_verzameling",
    "_parent_id": "abc"
}
----

IMPORTANT: De parent collectie moet al bestaan anders werkt het linken niet.

Deze manier van linken ondersteund alleen alleen 1 - n, daarom kunnen features gelinked worden met link().

[source, json]
----
{
    "_action": "new",
    "_id": "xyz",
    "_collection": "vooprbeeld_verzameling_2",
    "_validity": "2012-01-01T00:00:00.000"
    "linked_item": ["~#link",["voorbeeld_verzameling", "abc"]],
     .
     .
     .
}
----

Dit mag een array zijn.

[source, json]
----
{
    "_action": "new",
    "_id": "xyz",
    "_collection": "voorbeeld_verzameling_2",
    "_validity": "2012-01-01T00:00:00.000"
    "linked_items": ["~#link" ["collectie1", "id1", "collectie2", "id2", ...]],
     .
     .
     .
}
----

IMPORTANT: De links moeten al bestaan op het moment van linken.

== Nested features
Linken van collecties vereist dat alle element een *_collection* en *_id* hebben. Het kan onwenselijk zijn om deze zelf bij te houden, daarom kunnen geneste features toegevoegd worden aan een feature. Dit is eventueel een array van objecten.

[source, json]
----
{
    "_action": "new",
    "_id": "klm",
    "_collection": "nested_parent",
    "_validity": "2012-01-01T00:00:00.000"
    "child_object": { "omschrijving": "ik ben genest", # <1>
                       "_geometry": { ... }
                     }
     "_geometry": { ... },
     "parent_info": "extra informatie"
}

{
    "_action": "new",
    "_id": "klm",
    "_collection": "nested_parent",
    "_validity": "2012-01-01T00:00:00.000"
    "child_object": [{ "omschrijving": "ik ben genest", # <2>
                       "_geometry": { ... }
                     },
                     { "omschrijving": "ik ben ook genest",
                       "_geometry": { ... }
                     ]
     "_geometry": { ... },
     "parent_info": "extra informatie"
}
----
<1> enkel object
<2> array van objecten


Op de achtergrond worden de geneste objecten in een eigen collectie gestopt. De childs worden verwijderd uit de parent.

[source, json]
----
{
    "_action": "new",
    "_id": "[uid]",
    "_collection": "nested_parent$child_object",
    "_validity": "2012-01-01T00:00:00.000"
    "_parent_collection": "nested_parent",
    "_parent_id": "klm",
    "omschrijving": "ik ben genest",
    "_geometry": { ... }
}
----

IMPORTANT: Bij een *change* van het *child_object* worden alle _huidige nested features_ *geCLOSEd* en worden de nieuwe aangemaakt.

== Feature zonder _geometry
Een feature moet altijd een geometry hebben, echter in sommige gevallen is het wenselijk om dit in een nested feature te stoppen.

NOTE: Het is mogelijk om geen geometry toe te voegen. Er moet dan wel een nested feature zijn die wel een geometry heeft.

Als het voorbeeld in <<Nested features>> geen _geometry zou hebben, dan zou op de achtergrond het volgende gebeuren.

[source, json, subs="verbatim,macros"]
----
{
    "_action": "new",
    "_id": "klm$[uid]",
    "_collection": "nested_parent$child_object",
    "_validity": "2012-01-01T00:00:00.000",
    pass:quotes[*"child_object$omschrijving": "ik ben genest"*],
    "_geometry": { ... },
    pass:quotes[*"parent_info": "extra informatie"*]
}
----

IMPORTANT: Bij een *change* worden alle _huidige nested features_ *geCLOSEd* en worden nieuwe features aangemaakt.

NOTE: Het verschil tussen een parent met en zonder geometrie is dat bij het eerste geval er ook een parent collectie is met daarin de parent zonder childs. In het tweede geval bestaat alleen de child collectie.

== Feature historie
Gebruik makend van het *_validity* attribuut kan er een historie bijgehouden worden. Hierdoor kunnen we "prikken" in het verleden.

* Een feature is geldig vanaf de validity datum bij het aanmaken (__new__). Dit is _"versie 1"_.
* Bij een change wordt versie 1 afgesloten en gaat de nieuwe versie in, oftewel _"versie 2"_.
* Dit kan een aantal keer door gaan. Elke keer resulterend in een afgesloten huidige en geopende nieuwe versie.
* Als laatste kan een feature gesloten (*close*) worden. Hierna is een feature niet meer beschikbaar.

[source, json]
----
{
    "_action": "new",
    "_id": "feature1",
    "_collection": "historie-voorbeeld",
    "_validity": "[t1]"
    "value": "foo"
}

{
    "_action": "change",
    "_id": "feature1",
    "_collection": "historie-voorbeeld",
    "_current_validity": "[t1]",
    "_validity": "[t2]"
    "value": "bar"
}

{
    "_action": "change",
    "_id": "feature1",
    "_collection": "historie-voorbeeld",
    "_current_validity": "[t2]",
    "_validity": "[t3]"
    "value": "baz"
}

{
    "_action": "close",
    "_id": "feature1",
    "_collection": "historie-voorbeeld",
    "_current_validity": "[t3]",
    "_validity": "[t4]"
}
----

Dit resulteert in de volgende historie:

----
    t1           t2               t3           t4
-----|------------|----------------|------------|-------------->
 X     value=foo      value=bar       value=baz       X
----
